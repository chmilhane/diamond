local theme = Diamond.Theme

function Diamond:MaskStencil(mask, rendering, invert = false: boolean)
    render.ClearStencil()
    render.SetStencilEnable(true)

    render.SetStencilWriteMask(1)
    render.SetStencilTestMask(1)

    render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
    render.SetStencilPassOperation(invert and STENCILOPERATION_REPLACE or STENCILOPERATION_KEEP)
    render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
    render.SetStencilReferenceValue(1)

    mask()

    render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
    render.SetStencilPassOperation(invert and STENCILOPERATION_REPLACE or STENCILOPERATION_KEEP)
    render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
    render.SetStencilReferenceValue(invert and 0 or 1)

    rendering(self, w, h)

    render.SetStencilEnable(false)
    render.ClearStencil()
end

local _cache = {}
function Diamond:DrawCircle(x = 0: number, y = 0: number, radius = 0: number, color, angleStart = 0: number, angleEnd = 360: number, shouldDraw = false: boolean)
    local cachePath = x .. y .. radius .. angleStart .. angleEnd
    if shouldDraw and _cache[cachePath] then
        local poly = _cache[cachePath]
        stopif not poly

        draw.NoTexture()
        surface.SetDrawColor(color)
        surface.DrawPoly(poly)

        return
    end

    local poly = {}
    poly[1] = { x = x, y = y }
    for i = math.min(angleStart, angleEnd), math.max(angleStart, angleEnd) do
        local a = math.rad(i)
        if angleStart < 0 then
            poly[#poly + 1] = { x = x + math.cos(a) * radius, y = y + math.sin(a) * radius }
        else
            poly[#poly + 1] = { x = x - math.cos(a) * radius, y = y - math.sin(a) * radius }
        end
    end
    poly[#poly + 1] = { x = x, y = y }

    if shouldDraw then
        _cache[cachePath] = poly

        draw.NoTexture()
        surface.SetDrawColor(color)
        surface.DrawPoly(poly)
    end

    return poly
end

function Diamond:DrawRoundedRect(radius, x, y, w, h, color)
    stopif w == 0 or h == 0

	surface.SetDrawColor(color)
	surface.DrawRect(x + radius, y, w - radius * 2, h)
	surface.DrawRect(x, y + radius, radius, h - radius * 2)
	surface.DrawRect(x + w - radius, y + radius, radius, h - radius * 2)

	self:DrawCircle(x + radius, y + radius, radius, color, -180, -90, true)
	self:DrawCircle(x + w - radius, y + radius, radius, color, -90, 0, true)
	self:DrawCircle(x + radius, y + h - radius, radius, color, -270, -180, true)
	self:DrawCircle(x + w - radius, y + h - radius, radius, color, 270, 180, true)
end

function Diamond:DrawRoundedOutlinedRect(radius, x, y, w, h, thickness, color)
    if radius == 0 then
        for i = 0, thickness / 2 - 1 do
            surface.SetDrawColor(color)
            surface.DrawOutlinedRect(i, i, w - i * 2, h - i * 2)
        end
        return
    end

    self:MaskStencil(function()
        self:DrawRoundedRect(radius, x + thickness / 2, y + thickness / 2, w - thickness, h - thickness, color)
    end, function()
        self:DrawRoundedRect(radius + 2, x, y, w, h, color)
    end, true)
end

function Diamond:DrawTexturedRect(x, y, w, h, mat, color, rotation)
    surface.SetMaterial(mat)
    surface.SetDrawColor(color or color_white)

    if not rotation then
        surface.DrawTexturedRect(x, y, w, h)
    else
        surface.DrawTexturedRectRotated(x + (w / 2), y + (h / 2), w, h, rotation)
    end
end

function Diamond:DrawRoundedTexturedRect(radius, x, y, w, h, mat, color, rotation)
    self:MaskStencil(function()
        self:DrawRoundedRect(radius, x, y, w, h, color)
    end, function()
        Diamond:DrawTexturedRect(x, y, w, h, mat, color, rotation)
    end)
end

function Diamond:FormatIcon(icon)
    return utf8.char(tonumber(string.format("0x%s", icon)))
end

local __cache = {}
function Diamond:GetIconFont(style, size)
    local path = `Diamond:${style}:${size}`
    if __cache[path] then return __cache[path] end

    local font = Diamond:Font(size, { font = string.format("Font Awesome 5 Free %s", style) })
    __cache[path] = font

    return font
end

function Diamond:DrawIcon(icon, style, size, x, y, xAlign, yAlign, color)
    draw.SimpleText(self:FormatIcon(icon), self:GetIconFont(style, size), x, y, color ?? color_white, xAlign, yAlign)
end

function Diamond:DrawRainbowText(font: string, x = 0: number, y = 0: number, xAlign = 0, yAlign = 1: number, ...)
    -- TODO
    -- local _markup = "<font=" .. font .. ">"

    -- for i, v in ipairs({...}) do
    --     _markup ..= IsColor(v) and "<color" or tostring(v)
    -- end

    -- _markup ..= "</font>"

    -- surface.SetFont(font)

    -- local currentX = x
    -- local currentColor = theme:get("text")

    -- local  content = { ... }
    -- local text = ""

    -- for i, v in ipairs(content or {}) do
    --     continueif IsColor(color)
    --     text ..= tostring(v)
    -- end

    -- local w, h = surface.GetTextSize(text)

    -- if xAlign == TEXT_ALIGN_CENTER then
    --     currentX -= w / 2
    -- elseif xAlign == TEXT_ALIGN_RIGHT then
    --     currentX -= w
    -- end

    -- if yAlign == TEXT_ALIGN_CENTER then
    --     y -= h / 2
    -- elseif yAlign == TEXT_ALIGN_BOTTOM then
    --     y -= h
    -- end
end

function Diamond:DrawDualText(title = {}: table, subtitle = {}: table, w: number, h: number, x = 0: number, y = 0: number, xAlign = 0: number, yAlign = 1: number)
    y = h / 2 - draw.GetFontHeight(subtitle.font) / 2
    draw.SimpleText(title.text, title.font, x, y, title.color ?? theme:get("text"), xAlign, yAlign)

    y = h / 2 + draw.GetFontHeight(subtitle.font) / 2
    draw.SimpleText(subtitle.text, subtitle.font, x, y, title.color ?? theme:lighten("text", -0.2), xAlign, yAlign)
end

local blur = Material("pp/blurscreen")
function Diamond:DrawBlur(panel, amount)
    local x, y = panel:LocalToScreen(0, 0)
    local scrW, scrH = ScrW(), ScrH()
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)

    for i = 1, 3 do
        blur:SetFloat("$blur", (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
    end
end

function Diamond:DrawBlurPos(x, y, w, h, amount)
	local _x, _y = 0,0

	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)

	for i = 1, amount or 5 do
		blur:SetFloat("$blur", (i / 3) * (5))
		blur:Recompute()

		render.UpdateScreenEffectTexture()

		render.SetScissorRect(x, y, x + w, y + h, true)
			surface.DrawTexturedRect(_x * -1, _y * -1, ScrW(), ScrH())
		render.SetScissorRect(0, 0, 0, 0, false)
	end
end

function Diamond:DrawEntity(content: table)
    surface.SetFont(content.font)
    local width = surface.GetTextSize(content.title)
    local height = draw.GetFontHeight(content.font)

    width += content.icon and 48 * 1.4 or 48
    height += 48 / 2

    local cx, cy = -width / 2, -height / 2

    draw.RoundedBox(theme:get("radius") / 2, cx, cy, width, height, theme:get("background"))
    draw.SimpleText(content.title, content.font, content.icon and 18.5 or 0, -1, theme:get("text"), 1, 1)

    if content.icon then
        Diamond:DrawIcon(content.icon, content.iconStyle or "Solid", draw.GetFontHeight(content.font) - 8, (-width / 2) + 28, 2, 1, 1, theme:get("text"))
    end
end